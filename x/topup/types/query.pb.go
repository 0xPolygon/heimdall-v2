// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: heimdallv2/topup/v1/query.proto

package types

import (
	context "context"
	fmt "fmt"
	types "github.com/0xPolygon/heimdall-v2/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryTopupSequenceRequest is the request type for the GetTopupTxSequence and
// IsTopupTxOld RPC methods
type QueryTopupSequenceRequest struct {
	TxHash   string `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	LogIndex uint64 `protobuf:"varint,2,opt,name=log_index,json=logIndex,proto3" json:"log_index,omitempty"`
}

func (m *QueryTopupSequenceRequest) Reset()         { *m = QueryTopupSequenceRequest{} }
func (m *QueryTopupSequenceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryTopupSequenceRequest) ProtoMessage()    {}
func (*QueryTopupSequenceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{0}
}
func (m *QueryTopupSequenceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTopupSequenceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTopupSequenceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTopupSequenceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTopupSequenceRequest.Merge(m, src)
}
func (m *QueryTopupSequenceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryTopupSequenceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTopupSequenceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTopupSequenceRequest proto.InternalMessageInfo

func (m *QueryTopupSequenceRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *QueryTopupSequenceRequest) GetLogIndex() uint64 {
	if m != nil {
		return m.LogIndex
	}
	return 0
}

// QueryTopupSequenceResponse is response type for the GetTopupTxSequence RPC
// method
type QueryTopupSequenceResponse struct {
	Sequence string `protobuf:"bytes,1,opt,name=sequence,proto3" json:"sequence"`
}

func (m *QueryTopupSequenceResponse) Reset()         { *m = QueryTopupSequenceResponse{} }
func (m *QueryTopupSequenceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTopupSequenceResponse) ProtoMessage()    {}
func (*QueryTopupSequenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{1}
}
func (m *QueryTopupSequenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTopupSequenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTopupSequenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTopupSequenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTopupSequenceResponse.Merge(m, src)
}
func (m *QueryTopupSequenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTopupSequenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTopupSequenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTopupSequenceResponse proto.InternalMessageInfo

func (m *QueryTopupSequenceResponse) GetSequence() string {
	if m != nil {
		return m.Sequence
	}
	return ""
}

// QueryIsTopupTxOldResponse is response type for the IsTopupTxOld RPC
// method
type QueryIsTopupTxOldResponse struct {
	IsOld bool `protobuf:"varint,1,opt,name=is_old,json=isOld,proto3" json:"isOld"`
}

func (m *QueryIsTopupTxOldResponse) Reset()         { *m = QueryIsTopupTxOldResponse{} }
func (m *QueryIsTopupTxOldResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIsTopupTxOldResponse) ProtoMessage()    {}
func (*QueryIsTopupTxOldResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{2}
}
func (m *QueryIsTopupTxOldResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIsTopupTxOldResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIsTopupTxOldResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIsTopupTxOldResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIsTopupTxOldResponse.Merge(m, src)
}
func (m *QueryIsTopupTxOldResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIsTopupTxOldResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIsTopupTxOldResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIsTopupTxOldResponse proto.InternalMessageInfo

func (m *QueryIsTopupTxOldResponse) GetIsOld() bool {
	if m != nil {
		return m.IsOld
	}
	return false
}

// QueryDividendAccountRequest is the request type for the
// GetDividendAccountByAddress RPC method
type QueryDividendAccountRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address"`
}

func (m *QueryDividendAccountRequest) Reset()         { *m = QueryDividendAccountRequest{} }
func (m *QueryDividendAccountRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountRequest) ProtoMessage()    {}
func (*QueryDividendAccountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{3}
}
func (m *QueryDividendAccountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountRequest.Merge(m, src)
}
func (m *QueryDividendAccountRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountRequest proto.InternalMessageInfo

func (m *QueryDividendAccountRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// QueryDividendAccountResponse the is response type for the
// GetDividendAccountByAddress RPC method
type QueryDividendAccountResponse struct {
	DividendAccount types.DividendAccount `protobuf:"bytes,2,opt,name=dividend_account,json=dividendAccount,proto3" json:"dividendAccount"`
}

func (m *QueryDividendAccountResponse) Reset()         { *m = QueryDividendAccountResponse{} }
func (m *QueryDividendAccountResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountResponse) ProtoMessage()    {}
func (*QueryDividendAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{4}
}
func (m *QueryDividendAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountResponse.Merge(m, src)
}
func (m *QueryDividendAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountResponse proto.InternalMessageInfo

func (m *QueryDividendAccountResponse) GetDividendAccount() types.DividendAccount {
	if m != nil {
		return m.DividendAccount
	}
	return types.DividendAccount{}
}

// QueryDividendAccountRootHashRequest is the request type for the
// GetDividendAccountRootHash RPC method
type QueryDividendAccountRootHashRequest struct {
}

func (m *QueryDividendAccountRootHashRequest) Reset()         { *m = QueryDividendAccountRootHashRequest{} }
func (m *QueryDividendAccountRootHashRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountRootHashRequest) ProtoMessage()    {}
func (*QueryDividendAccountRootHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{5}
}
func (m *QueryDividendAccountRootHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountRootHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountRootHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountRootHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountRootHashRequest.Merge(m, src)
}
func (m *QueryDividendAccountRootHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountRootHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountRootHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountRootHashRequest proto.InternalMessageInfo

// QueryDividendAccountRootResponse the is response type for the
// GetDividendAccountRootHash RPC method
type QueryDividendAccountRootHashResponse struct {
	AccountRootHash *types.HeimdallHash `protobuf:"bytes,2,opt,name=account_root_hash,json=accountRootHash,proto3" json:"accountRootHash"`
}

func (m *QueryDividendAccountRootHashResponse) Reset()         { *m = QueryDividendAccountRootHashResponse{} }
func (m *QueryDividendAccountRootHashResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountRootHashResponse) ProtoMessage()    {}
func (*QueryDividendAccountRootHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{6}
}
func (m *QueryDividendAccountRootHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountRootHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountRootHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountRootHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountRootHashResponse.Merge(m, src)
}
func (m *QueryDividendAccountRootHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountRootHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountRootHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountRootHashResponse proto.InternalMessageInfo

func (m *QueryDividendAccountRootHashResponse) GetAccountRootHash() *types.HeimdallHash {
	if m != nil {
		return m.AccountRootHash
	}
	return nil
}

// QueryVerifyAccountProofParams is the request type for the VerifyAccountProof
// RPC method
type QueryVerifyAccountProofRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address"`
	Proof   string `protobuf:"bytes,2,opt,name=proof,proto3" json:"accountProof"`
}

func (m *QueryVerifyAccountProofRequest) Reset()         { *m = QueryVerifyAccountProofRequest{} }
func (m *QueryVerifyAccountProofRequest) String() string { return proto.CompactTextString(m) }
func (*QueryVerifyAccountProofRequest) ProtoMessage()    {}
func (*QueryVerifyAccountProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{7}
}
func (m *QueryVerifyAccountProofRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVerifyAccountProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVerifyAccountProofRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVerifyAccountProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVerifyAccountProofRequest.Merge(m, src)
}
func (m *QueryVerifyAccountProofRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryVerifyAccountProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVerifyAccountProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVerifyAccountProofRequest proto.InternalMessageInfo

func (m *QueryVerifyAccountProofRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryVerifyAccountProofRequest) GetProof() string {
	if m != nil {
		return m.Proof
	}
	return ""
}

// QueryVerifyAccountProofResponse the is response type for the
// VerifyAccountProof RPC method
type QueryVerifyAccountProofResponse struct {
	// TODO HV2: check VerifyAccountProofHandlerFn where result can also be
	// embedded in a map.
	IsVerified bool `protobuf:"varint,2,opt,name=is_verified,json=isVerified,proto3" json:"isVerified"`
}

func (m *QueryVerifyAccountProofResponse) Reset()         { *m = QueryVerifyAccountProofResponse{} }
func (m *QueryVerifyAccountProofResponse) String() string { return proto.CompactTextString(m) }
func (*QueryVerifyAccountProofResponse) ProtoMessage()    {}
func (*QueryVerifyAccountProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{8}
}
func (m *QueryVerifyAccountProofResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVerifyAccountProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVerifyAccountProofResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVerifyAccountProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVerifyAccountProofResponse.Merge(m, src)
}
func (m *QueryVerifyAccountProofResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryVerifyAccountProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVerifyAccountProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVerifyAccountProofResponse proto.InternalMessageInfo

func (m *QueryVerifyAccountProofResponse) GetIsVerified() bool {
	if m != nil {
		return m.IsVerified
	}
	return false
}

// QueryDividendAccountProofParams is the request type for the
// GetDividendAccountProof RPC method
type QueryDividendAccountProofRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address"`
}

func (m *QueryDividendAccountProofRequest) Reset()         { *m = QueryDividendAccountProofRequest{} }
func (m *QueryDividendAccountProofRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountProofRequest) ProtoMessage()    {}
func (*QueryDividendAccountProofRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{9}
}
func (m *QueryDividendAccountProofRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountProofRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountProofRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountProofRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountProofRequest.Merge(m, src)
}
func (m *QueryDividendAccountProofRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountProofRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountProofRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountProofRequest proto.InternalMessageInfo

func (m *QueryDividendAccountProofRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// QueryDividendAccountProofResponse the is response type for the
// GetDividendAccountProof RPC method
type QueryDividendAccountProofResponse struct {
	Proof *DividendAccountProof `protobuf:"bytes,2,opt,name=proof,proto3" json:"proof"`
}

func (m *QueryDividendAccountProofResponse) Reset()         { *m = QueryDividendAccountProofResponse{} }
func (m *QueryDividendAccountProofResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountProofResponse) ProtoMessage()    {}
func (*QueryDividendAccountProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{10}
}
func (m *QueryDividendAccountProofResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountProofResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountProofResponse.Merge(m, src)
}
func (m *QueryDividendAccountProofResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountProofResponse proto.InternalMessageInfo

func (m *QueryDividendAccountProofResponse) GetProof() *DividendAccountProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

// DividendAccountProof embeds user and account info for the the
// QueryDividendAccountProofResponse
type DividendAccountProof struct {
	Address      string `protobuf:"bytes,1,opt,name=address,proto3" json:"address"`
	AccountProof string `protobuf:"bytes,2,opt,name=account_proof,json=accountProof,proto3" json:"accountProof"`
	Index        uint64 `protobuf:"varint,3,opt,name=index,proto3" json:"index"`
}

func (m *DividendAccountProof) Reset()         { *m = DividendAccountProof{} }
func (m *DividendAccountProof) String() string { return proto.CompactTextString(m) }
func (*DividendAccountProof) ProtoMessage()    {}
func (*DividendAccountProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_c289e17b6179cf02, []int{11}
}
func (m *DividendAccountProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DividendAccountProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DividendAccountProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DividendAccountProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DividendAccountProof.Merge(m, src)
}
func (m *DividendAccountProof) XXX_Size() int {
	return m.Size()
}
func (m *DividendAccountProof) XXX_DiscardUnknown() {
	xxx_messageInfo_DividendAccountProof.DiscardUnknown(m)
}

var xxx_messageInfo_DividendAccountProof proto.InternalMessageInfo

func (m *DividendAccountProof) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *DividendAccountProof) GetAccountProof() string {
	if m != nil {
		return m.AccountProof
	}
	return ""
}

func (m *DividendAccountProof) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func init() {
	proto.RegisterType((*QueryTopupSequenceRequest)(nil), "heimdallv2.topup.v1.QueryTopupSequenceRequest")
	proto.RegisterType((*QueryTopupSequenceResponse)(nil), "heimdallv2.topup.v1.QueryTopupSequenceResponse")
	proto.RegisterType((*QueryIsTopupTxOldResponse)(nil), "heimdallv2.topup.v1.QueryIsTopupTxOldResponse")
	proto.RegisterType((*QueryDividendAccountRequest)(nil), "heimdallv2.topup.v1.QueryDividendAccountRequest")
	proto.RegisterType((*QueryDividendAccountResponse)(nil), "heimdallv2.topup.v1.QueryDividendAccountResponse")
	proto.RegisterType((*QueryDividendAccountRootHashRequest)(nil), "heimdallv2.topup.v1.QueryDividendAccountRootHashRequest")
	proto.RegisterType((*QueryDividendAccountRootHashResponse)(nil), "heimdallv2.topup.v1.QueryDividendAccountRootHashResponse")
	proto.RegisterType((*QueryVerifyAccountProofRequest)(nil), "heimdallv2.topup.v1.QueryVerifyAccountProofRequest")
	proto.RegisterType((*QueryVerifyAccountProofResponse)(nil), "heimdallv2.topup.v1.QueryVerifyAccountProofResponse")
	proto.RegisterType((*QueryDividendAccountProofRequest)(nil), "heimdallv2.topup.v1.QueryDividendAccountProofRequest")
	proto.RegisterType((*QueryDividendAccountProofResponse)(nil), "heimdallv2.topup.v1.QueryDividendAccountProofResponse")
	proto.RegisterType((*DividendAccountProof)(nil), "heimdallv2.topup.v1.DividendAccountProof")
}

func init() { proto.RegisterFile("heimdallv2/topup/v1/query.proto", fileDescriptor_c289e17b6179cf02) }

var fileDescriptor_c289e17b6179cf02 = []byte{
	// 921 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xcf, 0x6f, 0xdc, 0x44,
	0x14, 0xc7, 0x33, 0x85, 0x4d, 0x37, 0x93, 0x02, 0xcd, 0x34, 0xa8, 0x89, 0x13, 0xd9, 0xa9, 0x69,
	0x49, 0xd2, 0xb2, 0x76, 0xb2, 0x0d, 0x15, 0x45, 0xe2, 0x50, 0x0b, 0xa9, 0xa9, 0x90, 0x48, 0x69,
	0xab, 0x22, 0x71, 0xb1, 0xdc, 0xf5, 0xd4, 0x3b, 0x92, 0xe3, 0x71, 0x77, 0x66, 0x57, 0xbb, 0x42,
	0x5c, 0x90, 0x90, 0x38, 0x70, 0x40, 0x42, 0xe2, 0xc8, 0x89, 0x03, 0x47, 0x0e, 0x5c, 0x41, 0xdc,
	0xe8, 0x8d, 0x0a, 0x2e, 0x9c, 0x56, 0x28, 0x41, 0x42, 0xda, 0xbf, 0xa2, 0x9a, 0x1f, 0xce, 0xee,
	0xda, 0xde, 0x68, 0x37, 0x97, 0xc4, 0x7e, 0x79, 0xf3, 0x9d, 0xcf, 0x7b, 0x6f, 0xe6, 0xeb, 0x40,
	0xab, 0x89, 0xc9, 0x61, 0x18, 0xc4, 0x71, 0xa7, 0xee, 0x72, 0x9a, 0xb6, 0x53, 0xb7, 0xb3, 0xeb,
	0x3e, 0x6b, 0xe3, 0x56, 0xcf, 0x49, 0x5b, 0x94, 0x53, 0x74, 0x69, 0x98, 0xe0, 0xc8, 0x04, 0xa7,
	0xb3, 0x6b, 0xac, 0x36, 0x28, 0x3b, 0xa4, 0xcc, 0x97, 0x29, 0xae, 0x7a, 0x51, 0xf9, 0xc6, 0x9a,
	0x7a, 0x53, 0x1a, 0x39, 0x31, 0x63, 0x29, 0x38, 0x24, 0x09, 0x75, 0xe5, 0x4f, 0x1d, 0x5a, 0x8e,
	0x68, 0x44, 0x95, 0x8e, 0x78, 0xd2, 0xd1, 0xf5, 0x88, 0xd2, 0x28, 0xc6, 0x6e, 0x90, 0x12, 0x37,
	0x48, 0x12, 0xca, 0x03, 0x4e, 0x68, 0x92, 0xed, 0xb1, 0x39, 0x0a, 0xdd, 0x4b, 0x31, 0x73, 0x43,
	0xd2, 0x21, 0x21, 0x4e, 0x42, 0x3f, 0x68, 0x34, 0x68, 0x3b, 0xe1, 0x19, 0x4c, 0x21, 0xb1, 0x19,
	0xb0, 0xa6, 0xfa, 0xa3, 0xed, 0xc3, 0xd5, 0x4f, 0x04, 0xdb, 0x23, 0x51, 0xd5, 0x43, 0xfc, 0xac,
	0x8d, 0x93, 0x06, 0x7e, 0x20, 0x7e, 0x33, 0x8e, 0x4c, 0x78, 0x9e, 0x77, 0x7d, 0x91, 0xbd, 0x02,
	0x36, 0xc0, 0xd6, 0x82, 0x57, 0xf9, 0xe9, 0xff, 0x9f, 0xaf, 0x83, 0x07, 0xf3, 0xbc, 0xbb, 0x1f,
	0xb0, 0x26, 0xb2, 0xe1, 0x42, 0x4c, 0x23, 0x9f, 0x24, 0x21, 0xee, 0xae, 0x9c, 0xdb, 0x00, 0x5b,
	0xaf, 0x66, 0x19, 0xd5, 0x98, 0x46, 0xf7, 0x44, 0xd8, 0xfe, 0x08, 0x1a, 0x65, 0x1b, 0xb0, 0x94,
	0x26, 0x0c, 0xa3, 0x1a, 0xac, 0x32, 0x1d, 0xd3, 0x5b, 0x2c, 0x0d, 0xfa, 0xd6, 0x49, 0x4c, 0x8b,
	0x65, 0xaf, 0xb6, 0xa7, 0x69, 0xef, 0x31, 0x29, 0xf7, 0xa8, 0x7b, 0x10, 0x87, 0x27, 0x5a, 0xd7,
	0xe0, 0x3c, 0x61, 0x3e, 0x8d, 0x43, 0xa9, 0x54, 0xf5, 0x5e, 0x1f, 0xf4, 0xad, 0x0a, 0x61, 0x07,
	0x71, 0xa8, 0x64, 0xd4, 0xb3, 0x1d, 0xc0, 0x35, 0xa9, 0xf1, 0xa1, 0xee, 0xd6, 0x1d, 0xd5, 0xac,
	0xac, 0x66, 0x0f, 0x9e, 0x0f, 0xc2, 0xb0, 0x85, 0x19, 0xd3, 0x40, 0x5b, 0x83, 0xbe, 0x95, 0x85,
	0xfe, 0xfa, 0xa5, 0xb6, 0xac, 0x07, 0x7d, 0x47, 0x45, 0x1e, 0xf2, 0x16, 0x49, 0x22, 0xb5, 0x41,
	0x96, 0x65, 0x7f, 0x05, 0xe0, 0x7a, 0xf9, 0x1e, 0x1a, 0x15, 0xc3, 0x8b, 0xf9, 0x61, 0xc9, 0xfe,
	0x2d, 0xd6, 0xaf, 0x38, 0xa3, 0x47, 0x4d, 0x4c, 0xcb, 0xc9, 0x89, 0x78, 0x97, 0x9f, 0xf7, 0xad,
	0xb9, 0x41, 0xdf, 0x7a, 0x23, 0xcc, 0xa9, 0xe7, 0x03, 0xf6, 0x35, 0xf8, 0x56, 0x29, 0x06, 0xa5,
	0x5c, 0xcc, 0x4f, 0x97, 0x6c, 0x7f, 0x03, 0xe0, 0xd5, 0xd3, 0xf3, 0x34, 0x76, 0x08, 0x97, 0x34,
	0xad, 0xdf, 0xa2, 0x94, 0xab, 0x93, 0xa1, 0xb8, 0xcd, 0x22, 0xf7, 0xbe, 0x0e, 0x08, 0x09, 0x6f,
	0x45, 0x00, 0x07, 0xe3, 0xba, 0xaa, 0x6b, 0xf9, 0xa8, 0xdd, 0x83, 0xa6, 0xa4, 0x79, 0x8c, 0x5b,
	0xe4, 0x69, 0x4f, 0xb3, 0xdc, 0x6f, 0x51, 0xfa, 0x34, 0x9b, 0xd1, 0xf5, 0xfc, 0x8c, 0x2e, 0x8e,
	0xcc, 0x68, 0x7c, 0x16, 0xe8, 0x06, 0xac, 0xa4, 0x62, 0xad, 0xe4, 0x5c, 0xf0, 0xde, 0x1c, 0xf4,
	0xad, 0x0b, 0xc1, 0x88, 0xa6, 0x3e, 0x1b, 0x32, 0xc7, 0xfe, 0x14, 0x5a, 0x13, 0xb7, 0xd6, 0x3d,
	0xd8, 0x83, 0x8b, 0x84, 0xf9, 0x1d, 0x91, 0x40, 0x70, 0x28, 0x55, 0xab, 0xde, 0xa5, 0x41, 0xdf,
	0x82, 0x84, 0x3d, 0xd6, 0x51, 0xa5, 0x39, 0x12, 0xb0, 0x3f, 0x86, 0x1b, 0x65, 0x1d, 0x3e, 0x6b,
	0x55, 0x36, 0x87, 0x57, 0x4e, 0xd1, 0xd3, 0xa8, 0x07, 0xa3, 0xa5, 0x2f, 0xd6, 0xb7, 0x9d, 0x12,
	0x17, 0x73, 0xca, 0x14, 0xd4, 0xd5, 0x49, 0x0b, 0xed, 0xf9, 0x11, 0xc0, 0xe5, 0xb2, 0xfc, 0x99,
	0x06, 0xf2, 0x3e, 0x7c, 0x2d, 0x3b, 0x44, 0x53, 0x0c, 0x66, 0x2c, 0x84, 0xae, 0xc2, 0x8a, 0x32,
	0x9b, 0x57, 0xa4, 0xd9, 0xa8, 0x1b, 0x2e, 0x02, 0xd9, 0x0d, 0x17, 0xcf, 0xf5, 0x3f, 0xab, 0xb0,
	0x22, 0xbb, 0x83, 0xbe, 0x07, 0xf0, 0xc2, 0xa8, 0x57, 0x20, 0xa7, 0xb4, 0x07, 0x13, 0x1d, 0xd0,
	0x38, 0x25, 0xbf, 0xcc, 0x83, 0xec, 0xb7, 0xbf, 0x16, 0x20, 0x5f, 0xfe, 0xfd, 0xdf, 0x77, 0xe7,
	0xd6, 0xd0, 0xaa, 0x5b, 0xf8, 0xae, 0x10, 0x46, 0xe3, 0x90, 0x77, 0xd1, 0x0f, 0x00, 0xa2, 0xbb,
	0x98, 0x6b, 0x85, 0x6c, 0xd7, 0x99, 0xf1, 0xdc, 0xa9, 0xf3, 0x35, 0xdf, 0xe6, 0x90, 0x6f, 0x1d,
	0x19, 0x45, 0xbe, 0xcc, 0x69, 0xd1, 0xaf, 0x00, 0xae, 0xdd, 0xc5, 0x3c, 0xef, 0x3d, 0x3d, 0x6d,
	0x7b, 0x68, 0x67, 0xf2, 0xce, 0xe5, 0xc6, 0x6a, 0xec, 0xce, 0xb0, 0x42, 0xd3, 0xde, 0x1e, 0xd2,
	0x3a, 0xe8, 0x9d, 0x22, 0x6d, 0xe6, 0x77, 0x35, 0x7d, 0x48, 0xdc, 0xcf, 0xf5, 0x21, 0xfb, 0x02,
	0xfd, 0x01, 0xa0, 0x51, 0xe4, 0xcf, 0x3c, 0x06, 0xbd, 0x37, 0x3d, 0xcc, 0xb8, 0x59, 0x1a, 0xb7,
	0xcf, 0xb0, 0x52, 0x97, 0xb3, 0x37, 0x2c, 0x67, 0x1b, 0x6d, 0x4e, 0x51, 0x8e, 0x30, 0x59, 0xf4,
	0x1b, 0x80, 0xa8, 0xe8, 0x47, 0xe8, 0xe6, 0x64, 0x8e, 0x89, 0xc6, 0x69, 0xec, 0xcd, 0xb6, 0x48,
	0x73, 0x7f, 0x30, 0xe4, 0xae, 0xa3, 0x9d, 0x22, 0xb7, 0xc6, 0xad, 0xc9, 0xeb, 0x3c, 0x9c, 0x81,
	0x2b, 0x4d, 0xb2, 0x87, 0x7e, 0x07, 0xf0, 0x72, 0x71, 0x14, 0xaa, 0x8a, 0x77, 0xa7, 0xee, 0xe6,
	0x58, 0x1d, 0xb7, 0x66, 0x5d, 0xa6, 0x2b, 0xb9, 0x35, 0xac, 0xe4, 0x06, 0xda, 0x9e, 0xba, 0x12,
	0x6f, 0xff, 0xf9, 0x91, 0x09, 0x5e, 0x1c, 0x99, 0xe0, 0xdf, 0x23, 0x13, 0x7c, 0x7b, 0x6c, 0xce,
	0xbd, 0x38, 0x36, 0xe7, 0xfe, 0x39, 0x36, 0xe7, 0x3e, 0x73, 0x22, 0xc2, 0x9b, 0xed, 0x27, 0x4e,
	0x83, 0x1e, 0xba, 0x3b, 0xdd, 0xfb, 0x34, 0xee, 0x45, 0x34, 0x39, 0x11, 0xae, 0x75, 0xea, 0x6e,
	0x57, 0x6b, 0xcb, 0x8f, 0xe2, 0x93, 0x79, 0xf9, 0x6f, 0xd7, 0xcd, 0x97, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x19, 0x32, 0x6e, 0xec, 0x73, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// IsTopupTxOld queries for a specific topup tx to check its status (old
	// means already submitted)
	IsTopupTxOld(ctx context.Context, in *QueryTopupSequenceRequest, opts ...grpc.CallOption) (*QueryIsTopupTxOldResponse, error)
	// GetTopupTxSequence queries for a specific topup tx to check its status (old
	// means already submitted) and returns the sequence of the tx
	GetTopupTxSequence(ctx context.Context, in *QueryTopupSequenceRequest, opts ...grpc.CallOption) (*QueryTopupSequenceResponse, error)
	// GetDividendAccountByAddress queries for a specific DividendAccount by its
	// address
	GetDividendAccountByAddress(ctx context.Context, in *QueryDividendAccountRequest, opts ...grpc.CallOption) (*QueryDividendAccountResponse, error)
	// GetDividendAccountRootHash queries for the dividend account of the genesis
	// root hash
	GetDividendAccountRootHash(ctx context.Context, in *QueryDividendAccountRootHashRequest, opts ...grpc.CallOption) (*QueryDividendAccountRootHashResponse, error)
	// VerifyAccountProof queries for the proof of an account given its address
	VerifyAccountProof(ctx context.Context, in *QueryVerifyAccountProofRequest, opts ...grpc.CallOption) (*QueryVerifyAccountProofResponse, error)
	// GetDividendAccountProof queries for the dividend account proof of a given
	// address
	GetDividendAccountProof(ctx context.Context, in *QueryDividendAccountProofRequest, opts ...grpc.CallOption) (*QueryDividendAccountProofResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) IsTopupTxOld(ctx context.Context, in *QueryTopupSequenceRequest, opts ...grpc.CallOption) (*QueryIsTopupTxOldResponse, error) {
	out := new(QueryIsTopupTxOldResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.v1.Query/IsTopupTxOld", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetTopupTxSequence(ctx context.Context, in *QueryTopupSequenceRequest, opts ...grpc.CallOption) (*QueryTopupSequenceResponse, error) {
	out := new(QueryTopupSequenceResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.v1.Query/GetTopupTxSequence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetDividendAccountByAddress(ctx context.Context, in *QueryDividendAccountRequest, opts ...grpc.CallOption) (*QueryDividendAccountResponse, error) {
	out := new(QueryDividendAccountResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.v1.Query/GetDividendAccountByAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetDividendAccountRootHash(ctx context.Context, in *QueryDividendAccountRootHashRequest, opts ...grpc.CallOption) (*QueryDividendAccountRootHashResponse, error) {
	out := new(QueryDividendAccountRootHashResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.v1.Query/GetDividendAccountRootHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VerifyAccountProof(ctx context.Context, in *QueryVerifyAccountProofRequest, opts ...grpc.CallOption) (*QueryVerifyAccountProofResponse, error) {
	out := new(QueryVerifyAccountProofResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.v1.Query/VerifyAccountProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GetDividendAccountProof(ctx context.Context, in *QueryDividendAccountProofRequest, opts ...grpc.CallOption) (*QueryDividendAccountProofResponse, error) {
	out := new(QueryDividendAccountProofResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.v1.Query/GetDividendAccountProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// IsTopupTxOld queries for a specific topup tx to check its status (old
	// means already submitted)
	IsTopupTxOld(context.Context, *QueryTopupSequenceRequest) (*QueryIsTopupTxOldResponse, error)
	// GetTopupTxSequence queries for a specific topup tx to check its status (old
	// means already submitted) and returns the sequence of the tx
	GetTopupTxSequence(context.Context, *QueryTopupSequenceRequest) (*QueryTopupSequenceResponse, error)
	// GetDividendAccountByAddress queries for a specific DividendAccount by its
	// address
	GetDividendAccountByAddress(context.Context, *QueryDividendAccountRequest) (*QueryDividendAccountResponse, error)
	// GetDividendAccountRootHash queries for the dividend account of the genesis
	// root hash
	GetDividendAccountRootHash(context.Context, *QueryDividendAccountRootHashRequest) (*QueryDividendAccountRootHashResponse, error)
	// VerifyAccountProof queries for the proof of an account given its address
	VerifyAccountProof(context.Context, *QueryVerifyAccountProofRequest) (*QueryVerifyAccountProofResponse, error)
	// GetDividendAccountProof queries for the dividend account proof of a given
	// address
	GetDividendAccountProof(context.Context, *QueryDividendAccountProofRequest) (*QueryDividendAccountProofResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) IsTopupTxOld(ctx context.Context, req *QueryTopupSequenceRequest) (*QueryIsTopupTxOldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsTopupTxOld not implemented")
}
func (*UnimplementedQueryServer) GetTopupTxSequence(ctx context.Context, req *QueryTopupSequenceRequest) (*QueryTopupSequenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopupTxSequence not implemented")
}
func (*UnimplementedQueryServer) GetDividendAccountByAddress(ctx context.Context, req *QueryDividendAccountRequest) (*QueryDividendAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDividendAccountByAddress not implemented")
}
func (*UnimplementedQueryServer) GetDividendAccountRootHash(ctx context.Context, req *QueryDividendAccountRootHashRequest) (*QueryDividendAccountRootHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDividendAccountRootHash not implemented")
}
func (*UnimplementedQueryServer) VerifyAccountProof(ctx context.Context, req *QueryVerifyAccountProofRequest) (*QueryVerifyAccountProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyAccountProof not implemented")
}
func (*UnimplementedQueryServer) GetDividendAccountProof(ctx context.Context, req *QueryDividendAccountProofRequest) (*QueryDividendAccountProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDividendAccountProof not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_IsTopupTxOld_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTopupSequenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IsTopupTxOld(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.v1.Query/IsTopupTxOld",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IsTopupTxOld(ctx, req.(*QueryTopupSequenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetTopupTxSequence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTopupSequenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetTopupTxSequence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.v1.Query/GetTopupTxSequence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetTopupTxSequence(ctx, req.(*QueryTopupSequenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetDividendAccountByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDividendAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetDividendAccountByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.v1.Query/GetDividendAccountByAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetDividendAccountByAddress(ctx, req.(*QueryDividendAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetDividendAccountRootHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDividendAccountRootHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetDividendAccountRootHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.v1.Query/GetDividendAccountRootHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetDividendAccountRootHash(ctx, req.(*QueryDividendAccountRootHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VerifyAccountProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVerifyAccountProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VerifyAccountProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.v1.Query/VerifyAccountProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VerifyAccountProof(ctx, req.(*QueryVerifyAccountProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GetDividendAccountProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDividendAccountProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GetDividendAccountProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.v1.Query/GetDividendAccountProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GetDividendAccountProof(ctx, req.(*QueryDividendAccountProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "heimdallv2.topup.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsTopupTxOld",
			Handler:    _Query_IsTopupTxOld_Handler,
		},
		{
			MethodName: "GetTopupTxSequence",
			Handler:    _Query_GetTopupTxSequence_Handler,
		},
		{
			MethodName: "GetDividendAccountByAddress",
			Handler:    _Query_GetDividendAccountByAddress_Handler,
		},
		{
			MethodName: "GetDividendAccountRootHash",
			Handler:    _Query_GetDividendAccountRootHash_Handler,
		},
		{
			MethodName: "VerifyAccountProof",
			Handler:    _Query_VerifyAccountProof_Handler,
		},
		{
			MethodName: "GetDividendAccountProof",
			Handler:    _Query_GetDividendAccountProof_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "heimdallv2/topup/v1/query.proto",
}

func (m *QueryTopupSequenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTopupSequenceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTopupSequenceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogIndex != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LogIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTopupSequenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTopupSequenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTopupSequenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sequence) > 0 {
		i -= len(m.Sequence)
		copy(dAtA[i:], m.Sequence)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sequence)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIsTopupTxOldResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIsTopupTxOldResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIsTopupTxOldResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsOld {
		i--
		if m.IsOld {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.DividendAccount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountRootHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountRootHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountRootHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountRootHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountRootHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountRootHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccountRootHash != nil {
		{
			size, err := m.AccountRootHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *QueryVerifyAccountProofRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVerifyAccountProofRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVerifyAccountProofRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVerifyAccountProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVerifyAccountProofResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVerifyAccountProofResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsVerified {
		i--
		if m.IsVerified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountProofRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountProofRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountProofRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountProofResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountProofResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proof != nil {
		{
			size, err := m.Proof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DividendAccountProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DividendAccountProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DividendAccountProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountProof) > 0 {
		i -= len(m.AccountProof)
		copy(dAtA[i:], m.AccountProof)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountProof)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryTopupSequenceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.LogIndex != 0 {
		n += 1 + sovQuery(uint64(m.LogIndex))
	}
	return n
}

func (m *QueryTopupSequenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sequence)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryIsTopupTxOldResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsOld {
		n += 2
	}
	return n
}

func (m *QueryDividendAccountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDividendAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DividendAccount.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryDividendAccountRootHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryDividendAccountRootHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountRootHash != nil {
		l = m.AccountRootHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVerifyAccountProofRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVerifyAccountProofResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsVerified {
		n += 2
	}
	return n
}

func (m *QueryDividendAccountProofRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDividendAccountProofResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DividendAccountProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.AccountProof)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovQuery(uint64(m.Index))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryTopupSequenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTopupSequenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTopupSequenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTopupSequenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTopupSequenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTopupSequenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sequence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIsTopupTxOldResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIsTopupTxOldResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIsTopupTxOldResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOld = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DividendAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DividendAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountRootHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountRootHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountRootHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountRootHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountRootHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountRootHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRootHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountRootHash == nil {
				m.AccountRootHash = &types.HeimdallHash{}
			}
			if err := m.AccountRootHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVerifyAccountProofRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVerifyAccountProofRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVerifyAccountProofRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVerifyAccountProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVerifyAccountProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVerifyAccountProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVerified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVerified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountProofRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountProofRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountProofRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &DividendAccountProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DividendAccountProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DividendAccountProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DividendAccountProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountProof", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountProof = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
