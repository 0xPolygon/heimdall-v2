// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: heimdallv2/topup/query.proto

package types

import (
	context "context"
	fmt "fmt"
	types "github.com/0xPolygon/heimdall-v2/types"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QuerySequenceParams is the request type for the TopupTxStatus RPC method
type QuerySequenceParams struct {
	TxHash   string `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	LogIndex uint64 `protobuf:"varint,2,opt,name=log_index,json=logIndex,proto3" json:"log_index,omitempty"`
}

func (m *QuerySequenceParams) Reset()         { *m = QuerySequenceParams{} }
func (m *QuerySequenceParams) String() string { return proto.CompactTextString(m) }
func (*QuerySequenceParams) ProtoMessage()    {}
func (*QuerySequenceParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{0}
}
func (m *QuerySequenceParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySequenceParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySequenceParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySequenceParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySequenceParams.Merge(m, src)
}
func (m *QuerySequenceParams) XXX_Size() int {
	return m.Size()
}
func (m *QuerySequenceParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySequenceParams.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySequenceParams proto.InternalMessageInfo

func (m *QuerySequenceParams) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *QuerySequenceParams) GetLogIndex() uint64 {
	if m != nil {
		return m.LogIndex
	}
	return 0
}

// QuerySequenceParamsResponse the is response type for the TopupTxStatus RPC
// method
type QuerySequenceParamsResponse struct {
	Sequence string `protobuf:"bytes,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
}

func (m *QuerySequenceParamsResponse) Reset()         { *m = QuerySequenceParamsResponse{} }
func (m *QuerySequenceParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySequenceParamsResponse) ProtoMessage()    {}
func (*QuerySequenceParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{1}
}
func (m *QuerySequenceParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySequenceParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySequenceParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySequenceParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySequenceParamsResponse.Merge(m, src)
}
func (m *QuerySequenceParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySequenceParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySequenceParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySequenceParamsResponse proto.InternalMessageInfo

func (m *QuerySequenceParamsResponse) GetSequence() string {
	if m != nil {
		return m.Sequence
	}
	return ""
}

// QueryDividendAccountParams is the request type for the
// DividendAccountByAddress RPC method
type QueryDividendAccountParams struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"user_addr"`
}

func (m *QueryDividendAccountParams) Reset()         { *m = QueryDividendAccountParams{} }
func (m *QueryDividendAccountParams) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountParams) ProtoMessage()    {}
func (*QueryDividendAccountParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{2}
}
func (m *QueryDividendAccountParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountParams.Merge(m, src)
}
func (m *QueryDividendAccountParams) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountParams.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountParams proto.InternalMessageInfo

func (m *QueryDividendAccountParams) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// QueryDividendAccountParamsResponse the is response type for the
// DividendAccountByAddress RPC method
type QueryDividendAccountParamsResponse struct {
	DividendAccount types.DividendAccount `protobuf:"bytes,2,opt,name=dividend_account,json=dividendAccount,proto3" json:"result"`
}

func (m *QueryDividendAccountParamsResponse) Reset()         { *m = QueryDividendAccountParamsResponse{} }
func (m *QueryDividendAccountParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountParamsResponse) ProtoMessage()    {}
func (*QueryDividendAccountParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{3}
}
func (m *QueryDividendAccountParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountParamsResponse.Merge(m, src)
}
func (m *QueryDividendAccountParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountParamsResponse proto.InternalMessageInfo

func (m *QueryDividendAccountParamsResponse) GetDividendAccount() types.DividendAccount {
	if m != nil {
		return m.DividendAccount
	}
	return types.DividendAccount{}
}

// QueryDividendAccountRootParams is the request type for the
// DividendAccountRoot RPC method
type QueryDividendAccountRootParams struct {
}

func (m *QueryDividendAccountRootParams) Reset()         { *m = QueryDividendAccountRootParams{} }
func (m *QueryDividendAccountRootParams) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountRootParams) ProtoMessage()    {}
func (*QueryDividendAccountRootParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{4}
}
func (m *QueryDividendAccountRootParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountRootParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountRootParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountRootParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountRootParams.Merge(m, src)
}
func (m *QueryDividendAccountRootParams) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountRootParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountRootParams.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountRootParams proto.InternalMessageInfo

// QueryDividendAccountRootResponse the is response type for the
// DividendAccountRoot RPC method
type QueryDividendAccountRootResponse struct {
	AccountRootHash *types.HeimdallHash `protobuf:"bytes,2,opt,name=account_root_hash,json=accountRootHash,proto3" json:"result"`
}

func (m *QueryDividendAccountRootResponse) Reset()         { *m = QueryDividendAccountRootResponse{} }
func (m *QueryDividendAccountRootResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountRootResponse) ProtoMessage()    {}
func (*QueryDividendAccountRootResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{5}
}
func (m *QueryDividendAccountRootResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountRootResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountRootResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountRootResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountRootResponse.Merge(m, src)
}
func (m *QueryDividendAccountRootResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountRootResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountRootResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountRootResponse proto.InternalMessageInfo

func (m *QueryDividendAccountRootResponse) GetAccountRootHash() *types.HeimdallHash {
	if m != nil {
		return m.AccountRootHash
	}
	return nil
}

// QueryVerifyAccountProofParams is the request type for the VerifyAccountProof
// RPC method
type QueryVerifyAccountProofParams struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"user_addr"`
	Proof   string `protobuf:"bytes,2,opt,name=proof,proto3" json:"account_proof"`
}

func (m *QueryVerifyAccountProofParams) Reset()         { *m = QueryVerifyAccountProofParams{} }
func (m *QueryVerifyAccountProofParams) String() string { return proto.CompactTextString(m) }
func (*QueryVerifyAccountProofParams) ProtoMessage()    {}
func (*QueryVerifyAccountProofParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{6}
}
func (m *QueryVerifyAccountProofParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVerifyAccountProofParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVerifyAccountProofParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVerifyAccountProofParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVerifyAccountProofParams.Merge(m, src)
}
func (m *QueryVerifyAccountProofParams) XXX_Size() int {
	return m.Size()
}
func (m *QueryVerifyAccountProofParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVerifyAccountProofParams.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVerifyAccountProofParams proto.InternalMessageInfo

func (m *QueryVerifyAccountProofParams) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryVerifyAccountProofParams) GetProof() string {
	if m != nil {
		return m.Proof
	}
	return ""
}

// QueryVerifyAccountProofResponse the is response type for the
// VerifyAccountProof RPC method
type QueryVerifyAccountProofResponse struct {
	// TODO HV2: check VerifyAccountProofHandlerFn where result can also be
	// embedded in a map.
	Result bool `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *QueryVerifyAccountProofResponse) Reset()         { *m = QueryVerifyAccountProofResponse{} }
func (m *QueryVerifyAccountProofResponse) String() string { return proto.CompactTextString(m) }
func (*QueryVerifyAccountProofResponse) ProtoMessage()    {}
func (*QueryVerifyAccountProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{7}
}
func (m *QueryVerifyAccountProofResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVerifyAccountProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVerifyAccountProofResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVerifyAccountProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVerifyAccountProofResponse.Merge(m, src)
}
func (m *QueryVerifyAccountProofResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryVerifyAccountProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVerifyAccountProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVerifyAccountProofResponse proto.InternalMessageInfo

func (m *QueryVerifyAccountProofResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// QueryDividendAccountProofParams is the request type for the
// DividendAccountProof RPC method
type QueryDividendAccountProofParams struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"user_addr"`
}

func (m *QueryDividendAccountProofParams) Reset()         { *m = QueryDividendAccountProofParams{} }
func (m *QueryDividendAccountProofParams) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountProofParams) ProtoMessage()    {}
func (*QueryDividendAccountProofParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{8}
}
func (m *QueryDividendAccountProofParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountProofParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountProofParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountProofParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountProofParams.Merge(m, src)
}
func (m *QueryDividendAccountProofParams) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountProofParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountProofParams.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountProofParams proto.InternalMessageInfo

func (m *QueryDividendAccountProofParams) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// QueryDividendAccountProofResponse the is response type for the
// DividendAccountProof RPC method
type QueryDividendAccountProofResponse struct {
	Result *DividendAccountProof `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *QueryDividendAccountProofResponse) Reset()         { *m = QueryDividendAccountProofResponse{} }
func (m *QueryDividendAccountProofResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDividendAccountProofResponse) ProtoMessage()    {}
func (*QueryDividendAccountProofResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{9}
}
func (m *QueryDividendAccountProofResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDividendAccountProofResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDividendAccountProofResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDividendAccountProofResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDividendAccountProofResponse.Merge(m, src)
}
func (m *QueryDividendAccountProofResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDividendAccountProofResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDividendAccountProofResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDividendAccountProofResponse proto.InternalMessageInfo

func (m *QueryDividendAccountProofResponse) GetResult() *DividendAccountProof {
	if m != nil {
		return m.Result
	}
	return nil
}

// DividendAccountProof embeds user and account info for the the
// QueryDividendAccountProofResponse
type DividendAccountProof struct {
	User         string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	AccountProof string `protobuf:"bytes,2,opt,name=account_proof,json=accountProof,proto3" json:"account_proof,omitempty"`
	Index        uint64 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *DividendAccountProof) Reset()         { *m = DividendAccountProof{} }
func (m *DividendAccountProof) String() string { return proto.CompactTextString(m) }
func (*DividendAccountProof) ProtoMessage()    {}
func (*DividendAccountProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fb53cd446974424, []int{10}
}
func (m *DividendAccountProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DividendAccountProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DividendAccountProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DividendAccountProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DividendAccountProof.Merge(m, src)
}
func (m *DividendAccountProof) XXX_Size() int {
	return m.Size()
}
func (m *DividendAccountProof) XXX_DiscardUnknown() {
	xxx_messageInfo_DividendAccountProof.DiscardUnknown(m)
}

var xxx_messageInfo_DividendAccountProof proto.InternalMessageInfo

func (m *DividendAccountProof) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *DividendAccountProof) GetAccountProof() string {
	if m != nil {
		return m.AccountProof
	}
	return ""
}

func (m *DividendAccountProof) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func init() {
	proto.RegisterType((*QuerySequenceParams)(nil), "heimdallv2.topup.QuerySequenceParams")
	proto.RegisterType((*QuerySequenceParamsResponse)(nil), "heimdallv2.topup.QuerySequenceParamsResponse")
	proto.RegisterType((*QueryDividendAccountParams)(nil), "heimdallv2.topup.QueryDividendAccountParams")
	proto.RegisterType((*QueryDividendAccountParamsResponse)(nil), "heimdallv2.topup.QueryDividendAccountParamsResponse")
	proto.RegisterType((*QueryDividendAccountRootParams)(nil), "heimdallv2.topup.QueryDividendAccountRootParams")
	proto.RegisterType((*QueryDividendAccountRootResponse)(nil), "heimdallv2.topup.QueryDividendAccountRootResponse")
	proto.RegisterType((*QueryVerifyAccountProofParams)(nil), "heimdallv2.topup.QueryVerifyAccountProofParams")
	proto.RegisterType((*QueryVerifyAccountProofResponse)(nil), "heimdallv2.topup.QueryVerifyAccountProofResponse")
	proto.RegisterType((*QueryDividendAccountProofParams)(nil), "heimdallv2.topup.QueryDividendAccountProofParams")
	proto.RegisterType((*QueryDividendAccountProofResponse)(nil), "heimdallv2.topup.QueryDividendAccountProofResponse")
	proto.RegisterType((*DividendAccountProof)(nil), "heimdallv2.topup.DividendAccountProof")
}

func init() { proto.RegisterFile("heimdallv2/topup/query.proto", fileDescriptor_6fb53cd446974424) }

var fileDescriptor_6fb53cd446974424 = []byte{
	// 829 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xcf, 0x4b, 0x1b, 0x5b,
	0x14, 0xc7, 0x33, 0x3e, 0x13, 0xcd, 0xf5, 0xf9, 0xd4, 0xab, 0x3c, 0x74, 0xa2, 0x93, 0x38, 0xf0,
	0xfc, 0xf5, 0xcc, 0x8c, 0x46, 0x29, 0x74, 0x51, 0xd0, 0x60, 0xc1, 0xae, 0x6a, 0xa3, 0x14, 0xfa,
	0x03, 0xc2, 0x98, 0x19, 0x27, 0x53, 0x26, 0x73, 0xe3, 0xdc, 0x99, 0x90, 0x54, 0x4a, 0xc1, 0x55,
	0x37, 0x85, 0x42, 0xff, 0x89, 0x2e, 0x5b, 0x28, 0x2d, 0xfd, 0x0f, 0x5c, 0x4a, 0xbb, 0xe9, 0x2a,
	0x14, 0x2d, 0x14, 0xfc, 0x13, 0xba, 0x2a, 0x73, 0xef, 0x9d, 0x99, 0xfc, 0x1a, 0x1a, 0xbb, 0x11,
	0xe7, 0xdc, 0xef, 0x39, 0xe7, 0x73, 0xce, 0xb9, 0xe7, 0x06, 0xcc, 0x96, 0x35, 0xa3, 0xa2, 0x2a,
	0xa6, 0x59, 0xcb, 0xc9, 0x0e, 0xaa, 0xba, 0x55, 0xf9, 0xd8, 0xd5, 0xec, 0x86, 0x54, 0xb5, 0x91,
	0x83, 0xe0, 0x78, 0x78, 0x2a, 0x91, 0x53, 0x7e, 0xa6, 0x84, 0x70, 0x05, 0xe1, 0x22, 0x39, 0x97,
	0xe9, 0x07, 0x15, 0xf3, 0x29, 0xfa, 0x45, 0x03, 0xc8, 0xb5, 0xf5, 0xd6, 0x48, 0xfc, 0x84, 0x52,
	0x31, 0x2c, 0x24, 0x93, 0xbf, 0xcc, 0x34, 0xa5, 0x23, 0x1d, 0xd1, 0x38, 0xde, 0x7f, 0xcc, 0x3a,
	0xab, 0x23, 0xa4, 0x9b, 0x9a, 0xac, 0x54, 0x0d, 0x59, 0xb1, 0x2c, 0xe4, 0x28, 0x8e, 0x81, 0x2c,
	0x3f, 0xc7, 0x62, 0x2b, 0x6e, 0xa3, 0xaa, 0x61, 0x59, 0x35, 0x6a, 0x86, 0xaa, 0x59, 0x6a, 0x51,
	0x29, 0x95, 0x90, 0x6b, 0x39, 0x3e, 0x4c, 0x97, 0xb0, 0xac, 0xe0, 0x32, 0x3d, 0x14, 0x1f, 0x80,
	0xc9, 0x7b, 0x1e, 0xdb, 0xbe, 0x76, 0xec, 0x6a, 0x56, 0x49, 0xdb, 0x53, 0x6c, 0xa5, 0x82, 0xa1,
	0x00, 0x86, 0x9c, 0x7a, 0xd1, 0xd3, 0x4d, 0x73, 0x19, 0x6e, 0x29, 0x99, 0x8f, 0xbf, 0xf9, 0xf1,
	0x76, 0x85, 0x2b, 0x24, 0x9c, 0xfa, 0xae, 0x82, 0xcb, 0x50, 0x04, 0x49, 0x13, 0xe9, 0x45, 0xc3,
	0x52, 0xb5, 0xfa, 0xf4, 0x40, 0x86, 0x5b, 0x1a, 0xf4, 0x15, 0xc3, 0x26, 0xd2, 0xef, 0x78, 0x66,
	0x71, 0x0b, 0xa4, 0x7a, 0x84, 0x2e, 0x68, 0xb8, 0x8a, 0x2c, 0xac, 0xc1, 0x79, 0x30, 0x8c, 0xd9,
	0x49, 0x7b, 0x8e, 0xc0, 0x2c, 0x1e, 0x02, 0x9e, 0x44, 0xd8, 0x61, 0x85, 0x6d, 0xd3, 0xba, 0x18,
	0xe3, 0x0e, 0x18, 0x52, 0x54, 0xd5, 0xd6, 0x30, 0x66, 0xfe, 0x2b, 0x57, 0xcd, 0x74, 0xd2, 0xc5,
	0x9a, 0x5d, 0xf4, 0xec, 0x9f, 0xdf, 0x67, 0xa7, 0xd8, 0x50, 0xb6, 0xa9, 0x6c, 0xdf, 0xb1, 0x0d,
	0x4b, 0xa7, 0x49, 0x7c, 0x57, 0xf1, 0x94, 0x03, 0x62, 0x74, 0x92, 0x80, 0xf6, 0x31, 0x18, 0xef,
	0x6c, 0x2f, 0xa9, 0x7b, 0x24, 0x37, 0x2f, 0xb5, 0xde, 0x0c, 0xaf, 0xbf, 0x52, 0x47, 0xa8, 0xfc,
	0x3f, 0x67, 0xcd, 0x74, 0xec, 0xaa, 0x99, 0x4e, 0xd8, 0x1a, 0x76, 0x4d, 0xa7, 0x30, 0xa6, 0xb6,
	0x0b, 0xc4, 0x0c, 0x10, 0x7a, 0x31, 0x14, 0x10, 0x62, 0x1c, 0xe2, 0x73, 0x90, 0x89, 0x52, 0x04,
	0x8c, 0x8f, 0xc0, 0x04, 0x43, 0x2b, 0xda, 0x08, 0x39, 0x74, 0x7c, 0x14, 0x52, 0xe8, 0x86, 0xdc,
	0x65, 0x06, 0x6f, 0x9e, 0xf9, 0xb1, 0x90, 0x8e, 0xf6, 0x67, 0x4c, 0x09, 0x13, 0x78, 0x0a, 0xf1,
	0x04, 0xcc, 0x11, 0x80, 0xfb, 0x9a, 0x6d, 0x1c, 0x35, 0xfc, 0x26, 0xd9, 0x08, 0x1d, 0xb1, 0x71,
	0xac, 0x76, 0x8e, 0x03, 0xb6, 0x8d, 0xa3, 0xbd, 0xed, 0x70, 0x15, 0xc4, 0xab, 0x9e, 0x33, 0xe1,
	0x4b, 0xe6, 0xff, 0xbd, 0x6a, 0xa6, 0x47, 0x7d, 0x78, 0x72, 0x40, 0xf5, 0x54, 0x24, 0x6e, 0x81,
	0x74, 0x44, 0xf2, 0xa0, 0xf8, 0x39, 0xc0, 0xf8, 0x49, 0xc4, 0xe1, 0xe0, 0xc2, 0x52, 0xa3, 0x78,
	0x97, 0x45, 0xe8, 0x9c, 0xf2, 0x9f, 0x16, 0x20, 0x3e, 0x01, 0xf3, 0x91, 0x01, 0x03, 0xa8, 0xdb,
	0x6d, 0x50, 0x23, 0xb9, 0x05, 0xa9, 0xf3, 0x15, 0x91, 0x7a, 0xf9, 0x77, 0xc2, 0x3f, 0x05, 0x53,
	0xbd, 0x64, 0x70, 0x06, 0x0c, 0x7a, 0x78, 0xed, 0xeb, 0x43, 0x4c, 0x70, 0x05, 0xb4, 0xb7, 0x93,
	0xf5, 0x99, 0x69, 0xfe, 0x56, 0x5a, 0xc3, 0xa4, 0x40, 0x9c, 0x2e, 0xf2, 0x5f, 0xad, 0x8b, 0x4c,
	0x6d, 0xb9, 0x9f, 0x09, 0x10, 0x27, 0x85, 0xc2, 0x97, 0x1c, 0x18, 0x3d, 0xf0, 0x98, 0x0f, 0xea,
	0xfb, 0x8e, 0xe2, 0xb8, 0x18, 0xfe, 0xd7, 0x5d, 0x4e, 0x8f, 0x8d, 0xe7, 0xb3, 0x7d, 0xc9, 0xfc,
	0xa6, 0x89, 0x0b, 0x2f, 0xbc, 0xfc, 0xa7, 0x5f, 0xbe, 0xbf, 0x1e, 0x48, 0xc1, 0x19, 0xb9, 0xeb,
	0x55, 0x36, 0x30, 0x32, 0x55, 0xa7, 0x0e, 0x3f, 0x71, 0x60, 0xba, 0x73, 0xd3, 0x1a, 0xdb, 0xfe,
	0xfd, 0x8a, 0xc8, 0xd9, 0x73, 0xcb, 0xf9, 0xcd, 0xeb, 0xa8, 0x03, 0xd0, 0x9b, 0x21, 0xa8, 0x04,
	0x57, 0xbb, 0x41, 0xfd, 0x2d, 0xcf, 0xb2, 0x6e, 0xcb, 0x27, 0xec, 0xf2, 0x3c, 0x83, 0xef, 0x38,
	0x30, 0xd9, 0x63, 0x95, 0xe1, 0x5a, 0x7f, 0x20, 0xe1, 0xc3, 0xc0, 0xe7, 0xfa, 0xf7, 0x08, 0xc0,
	0x37, 0x43, 0xf0, 0x65, 0xb8, 0xf8, 0x7b, 0xf0, 0xac, 0xf7, 0x9c, 0xc0, 0x8f, 0x1c, 0x80, 0xdd,
	0x0b, 0x08, 0xe5, 0x08, 0x80, 0xa8, 0x87, 0x82, 0x5f, 0xef, 0xdb, 0x21, 0x00, 0xbe, 0x15, 0x02,
	0xe7, 0xe0, 0x5a, 0x37, 0xb0, 0xcf, 0x49, 0xae, 0x7a, 0xd8, 0x66, 0xb9, 0x46, 0x42, 0xc2, 0x0f,
	0x5c, 0xc4, 0x02, 0xad, 0xf7, 0x39, 0xf7, 0x16, 0xfa, 0x8d, 0x6b, 0xb8, 0x04, 0xfc, 0x37, 0x42,
	0xfe, 0xff, 0xe1, 0x72, 0xdf, 0xfc, 0xf9, 0xdd, 0xb3, 0x0b, 0x81, 0x3b, 0xbf, 0x10, 0xb8, 0x6f,
	0x17, 0x02, 0xf7, 0xea, 0x52, 0x88, 0x9d, 0x5f, 0x0a, 0xb1, 0xaf, 0x97, 0x42, 0xec, 0xa1, 0xa4,
	0x1b, 0x4e, 0xd9, 0x3d, 0x94, 0x4a, 0xa8, 0x22, 0xaf, 0xd5, 0xf7, 0x90, 0xd9, 0xd0, 0x91, 0x15,
	0x04, 0xce, 0xd6, 0x72, 0x72, 0x9d, 0xc5, 0x26, 0xaf, 0xfd, 0x61, 0x82, 0xfc, 0xdc, 0x6f, 0xfc,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0xea, 0xf8, 0xeb, 0x1d, 0xe5, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// TopupTxStatus queries for a specific topup tx to check its status (old
	// means already submitted)
	TopupTxStatus(ctx context.Context, in *QuerySequenceParams, opts ...grpc.CallOption) (*QuerySequenceParamsResponse, error)
	// DividendAccountByAddress queries for a specific DividendAccount by its
	// address
	DividendAccountByAddress(ctx context.Context, in *QueryDividendAccountParams, opts ...grpc.CallOption) (*QueryDividendAccountParamsResponse, error)
	// DividendAccountRoot queries for the dividend account of the genesis root
	// hash
	DividendAccountRoot(ctx context.Context, in *QueryDividendAccountRootParams, opts ...grpc.CallOption) (*QueryDividendAccountRootResponse, error)
	// VerifyAccountProof queries for the dividend account of the genesis root
	// hash
	VerifyAccountProof(ctx context.Context, in *QueryVerifyAccountProofParams, opts ...grpc.CallOption) (*QueryVerifyAccountProofResponse, error)
	// DividendAccountProof queries for the dividend account proof of a given
	// address
	DividendAccountProof(ctx context.Context, in *QueryDividendAccountProofParams, opts ...grpc.CallOption) (*QueryDividendAccountProofResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) TopupTxStatus(ctx context.Context, in *QuerySequenceParams, opts ...grpc.CallOption) (*QuerySequenceParamsResponse, error) {
	out := new(QuerySequenceParamsResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.Query/TopupTxStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DividendAccountByAddress(ctx context.Context, in *QueryDividendAccountParams, opts ...grpc.CallOption) (*QueryDividendAccountParamsResponse, error) {
	out := new(QueryDividendAccountParamsResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.Query/DividendAccountByAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DividendAccountRoot(ctx context.Context, in *QueryDividendAccountRootParams, opts ...grpc.CallOption) (*QueryDividendAccountRootResponse, error) {
	out := new(QueryDividendAccountRootResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.Query/DividendAccountRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VerifyAccountProof(ctx context.Context, in *QueryVerifyAccountProofParams, opts ...grpc.CallOption) (*QueryVerifyAccountProofResponse, error) {
	out := new(QueryVerifyAccountProofResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.Query/VerifyAccountProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DividendAccountProof(ctx context.Context, in *QueryDividendAccountProofParams, opts ...grpc.CallOption) (*QueryDividendAccountProofResponse, error) {
	out := new(QueryDividendAccountProofResponse)
	err := c.cc.Invoke(ctx, "/heimdallv2.topup.Query/DividendAccountProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// TopupTxStatus queries for a specific topup tx to check its status (old
	// means already submitted)
	TopupTxStatus(context.Context, *QuerySequenceParams) (*QuerySequenceParamsResponse, error)
	// DividendAccountByAddress queries for a specific DividendAccount by its
	// address
	DividendAccountByAddress(context.Context, *QueryDividendAccountParams) (*QueryDividendAccountParamsResponse, error)
	// DividendAccountRoot queries for the dividend account of the genesis root
	// hash
	DividendAccountRoot(context.Context, *QueryDividendAccountRootParams) (*QueryDividendAccountRootResponse, error)
	// VerifyAccountProof queries for the dividend account of the genesis root
	// hash
	VerifyAccountProof(context.Context, *QueryVerifyAccountProofParams) (*QueryVerifyAccountProofResponse, error)
	// DividendAccountProof queries for the dividend account proof of a given
	// address
	DividendAccountProof(context.Context, *QueryDividendAccountProofParams) (*QueryDividendAccountProofResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) TopupTxStatus(ctx context.Context, req *QuerySequenceParams) (*QuerySequenceParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TopupTxStatus not implemented")
}
func (*UnimplementedQueryServer) DividendAccountByAddress(ctx context.Context, req *QueryDividendAccountParams) (*QueryDividendAccountParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DividendAccountByAddress not implemented")
}
func (*UnimplementedQueryServer) DividendAccountRoot(ctx context.Context, req *QueryDividendAccountRootParams) (*QueryDividendAccountRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DividendAccountRoot not implemented")
}
func (*UnimplementedQueryServer) VerifyAccountProof(ctx context.Context, req *QueryVerifyAccountProofParams) (*QueryVerifyAccountProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyAccountProof not implemented")
}
func (*UnimplementedQueryServer) DividendAccountProof(ctx context.Context, req *QueryDividendAccountProofParams) (*QueryDividendAccountProofResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DividendAccountProof not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_TopupTxStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySequenceParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TopupTxStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.Query/TopupTxStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TopupTxStatus(ctx, req.(*QuerySequenceParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DividendAccountByAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDividendAccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DividendAccountByAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.Query/DividendAccountByAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DividendAccountByAddress(ctx, req.(*QueryDividendAccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DividendAccountRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDividendAccountRootParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DividendAccountRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.Query/DividendAccountRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DividendAccountRoot(ctx, req.(*QueryDividendAccountRootParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VerifyAccountProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVerifyAccountProofParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VerifyAccountProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.Query/VerifyAccountProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VerifyAccountProof(ctx, req.(*QueryVerifyAccountProofParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DividendAccountProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDividendAccountProofParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DividendAccountProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/heimdallv2.topup.Query/DividendAccountProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DividendAccountProof(ctx, req.(*QueryDividendAccountProofParams))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "heimdallv2.topup.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TopupTxStatus",
			Handler:    _Query_TopupTxStatus_Handler,
		},
		{
			MethodName: "DividendAccountByAddress",
			Handler:    _Query_DividendAccountByAddress_Handler,
		},
		{
			MethodName: "DividendAccountRoot",
			Handler:    _Query_DividendAccountRoot_Handler,
		},
		{
			MethodName: "VerifyAccountProof",
			Handler:    _Query_VerifyAccountProof_Handler,
		},
		{
			MethodName: "DividendAccountProof",
			Handler:    _Query_DividendAccountProof_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "heimdallv2/topup/query.proto",
}

func (m *QuerySequenceParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySequenceParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySequenceParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogIndex != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LogIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySequenceParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySequenceParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySequenceParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sequence) > 0 {
		i -= len(m.Sequence)
		copy(dAtA[i:], m.Sequence)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Sequence)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.DividendAccount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountRootParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountRootParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountRootParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountRootResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountRootResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountRootResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccountRootHash != nil {
		{
			size, err := m.AccountRootHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *QueryVerifyAccountProofParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVerifyAccountProofParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVerifyAccountProofParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVerifyAccountProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVerifyAccountProofResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVerifyAccountProofResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountProofParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountProofParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountProofParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDividendAccountProofResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDividendAccountProofResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDividendAccountProofResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DividendAccountProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DividendAccountProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DividendAccountProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountProof) > 0 {
		i -= len(m.AccountProof)
		copy(dAtA[i:], m.AccountProof)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountProof)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QuerySequenceParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.LogIndex != 0 {
		n += 1 + sovQuery(uint64(m.LogIndex))
	}
	return n
}

func (m *QuerySequenceParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sequence)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDividendAccountParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDividendAccountParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DividendAccount.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryDividendAccountRootParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryDividendAccountRootResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountRootHash != nil {
		l = m.AccountRootHash.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVerifyAccountProofParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVerifyAccountProofResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *QueryDividendAccountProofParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDividendAccountProofResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *DividendAccountProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.AccountProof)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovQuery(uint64(m.Index))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QuerySequenceParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySequenceParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySequenceParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySequenceParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySequenceParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySequenceParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sequence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DividendAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DividendAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountRootParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountRootParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountRootParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountRootResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountRootResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountRootResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRootHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountRootHash == nil {
				m.AccountRootHash = &types.HeimdallHash{}
			}
			if err := m.AccountRootHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVerifyAccountProofParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVerifyAccountProofParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVerifyAccountProofParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVerifyAccountProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVerifyAccountProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVerifyAccountProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountProofParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountProofParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountProofParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDividendAccountProofResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDividendAccountProofResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDividendAccountProofResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &DividendAccountProof{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DividendAccountProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DividendAccountProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DividendAccountProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountProof", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountProof = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
